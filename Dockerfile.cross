# syntax=docker/dockerfile:1

ARG DEBIAN_RELEASE=trixie
FROM debian:${DEBIAN_RELEASE}

ARG DEBIAN_RELEASE
ARG TARGET_ARCH=armhf
ARG BUILD_TESTS=false

# Environment setup
ENV DEBIAN_FRONTEND=noninteractive \
    TARGET_ARCH=${TARGET_ARCH} \
    BUILD_TESTS=${BUILD_TESTS}

# Add architecture and update sources
RUN dpkg --add-architecture ${TARGET_ARCH} && \
    apt-get update && \
    apt-get upgrade -y

# Install build dependencies
RUN apt-get install -y \
    build-essential \
    cmake \
    pkg-config \
    git \
    curl \
    wget \
    python3 \
    python3-pip \
    crossbuild-essential-${TARGET_ARCH} \
    libc6-dev:${TARGET_ARCH} \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Install cross-compilation specific packages
RUN <<EOF
if [ "${TARGET_ARCH}" = "armhf" ]; then
    apt-get update
    apt-get install -y \
        gcc-arm-linux-gnueabihf \
        g++-arm-linux-gnueabihf
    apt-get clean
    rm -rf /var/lib/apt/lists/*
elif [ "${TARGET_ARCH}" = "arm64" ]; then
    apt-get update
    apt-get install -y \
        gcc-aarch64-linux-gnu \
        g++-aarch64-linux-gnu
    apt-get clean
    rm -rf /var/lib/apt/lists/*
fi
EOF

# Install target architecture libraries
RUN apt-get update && apt-get install -y \
    libboost-all-dev:${TARGET_ARCH} \
    libprotobuf-dev:${TARGET_ARCH} \
    protobuf-compiler \
    libssl-dev:${TARGET_ARCH} \
    libasound2-dev:${TARGET_ARCH} \
    libpulse-dev:${TARGET_ARCH} \
    qtbase5-dev:${TARGET_ARCH} \
    qtmultimedia5-dev:${TARGET_ARCH} \
    libqt5multimedia5-plugins:${TARGET_ARCH} \
    qttools5-dev:${TARGET_ARCH} \
    qtdeclarative5-dev:${TARGET_ARCH} \
    libusb-1.0-0-dev:${TARGET_ARCH} \
    librtaudio-dev:${TARGET_ARCH} \
    libtag1-dev:${TARGET_ARCH} \
    libblkid-dev:${TARGET_ARCH} \
    libgps-dev:${TARGET_ARCH} \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Install test dependencies if needed
RUN <<EOF
if [ "${BUILD_TESTS}" = "true" ]; then
    apt-get update
    apt-get install -y \
        libgtest-dev:${TARGET_ARCH} \
        libgmock-dev:${TARGET_ARCH} \
        qtbase5-dev-tools
    apt-get clean
    rm -rf /var/lib/apt/lists/*
fi
EOF

# Set up cross-compilation environment variables
RUN <<EOF
if [ "${TARGET_ARCH}" = "armhf" ]; then
    {
        echo "export CC=arm-linux-gnueabihf-gcc"
        echo "export CXX=arm-linux-gnueabihf-g++"
        echo "export AR=arm-linux-gnueabihf-ar"
        echo "export STRIP=arm-linux-gnueabihf-strip"
        echo "export PKG_CONFIG_PATH=/usr/lib/arm-linux-gnueabihf/pkgconfig"
    } >> /etc/environment
elif [ "${TARGET_ARCH}" = "arm64" ]; then
    {
        echo "export CC=aarch64-linux-gnu-gcc"
        echo "export CXX=aarch64-linux-gnu-g++"
        echo "export AR=aarch64-linux-gnu-ar"
        echo "export STRIP=aarch64-linux-gnu-strip"
        echo "export PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig"
    } >> /etc/environment
fi
EOF

# Create CMake toolchain files
COPY <<EOF /toolchain-armhf.cmake
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm)

set(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc)
set(CMAKE_CXX_COMPILER arm-linux-gnueabihf-g++)
set(CMAKE_AR arm-linux-gnueabihf-ar)
set(CMAKE_STRIP arm-linux-gnueabihf-strip)

set(CMAKE_FIND_ROOT_PATH /usr/arm-linux-gnueabihf)
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

set(PKG_CONFIG_EXECUTABLE /usr/bin/pkg-config)
set(ENV{PKG_CONFIG_PATH} /usr/lib/arm-linux-gnueabihf/pkgconfig)
EOF

COPY <<EOF /toolchain-arm64.cmake
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR aarch64)

set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
set(CMAKE_AR aarch64-linux-gnu-ar)
set(CMAKE_STRIP aarch64-linux-gnu-strip)

set(CMAKE_FIND_ROOT_PATH /usr/aarch64-linux-gnu)
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

set(PKG_CONFIG_EXECUTABLE /usr/bin/pkg-config)
set(ENV{PKG_CONFIG_PATH} /usr/lib/aarch64-linux-gnu/pkgconfig)
EOF

# Create build script
COPY <<EOF /build.sh
#!/bin/bash
set -e

# Source environment
source /etc/environment

# Set cross-compilation variables
if [ "\${TARGET_ARCH}" = "armhf" ]; then
    export CMAKE_TOOLCHAIN_FILE=/toolchain-armhf.cmake
    export CROSS_COMPILE=arm-linux-gnueabihf-
    export ARCH_SUFFIX=arm-linux-gnueabihf
elif [ "\${TARGET_ARCH}" = "arm64" ]; then
    export CMAKE_TOOLCHAIN_FILE=/toolchain-arm64.cmake
    export CROSS_COMPILE=aarch64-linux-gnu-
    export ARCH_SUFFIX=aarch64-linux-gnu
fi

echo "Building OpenAuto for \${TARGET_ARCH}"
echo "Using toolchain: \${CMAKE_TOOLCHAIN_FILE}"

cd /src

# Create build directory
mkdir -p build
cd build

# Configure CMake
CMAKE_ARGS=(
    -DCMAKE_BUILD_TYPE=Release
    -DCMAKE_TOOLCHAIN_FILE=\${CMAKE_TOOLCHAIN_FILE}
    -DCMAKE_FIND_ROOT_PATH="/usr/\${ARCH_SUFFIX}"
    -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER
    -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY
    -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY
    -DNOPI=true
)

# Add test configuration
if [ "\${BUILD_TESTS}" = "true" ]; then
    CMAKE_ARGS+=(-DBUILD_TESTS=ON)
else
    CMAKE_ARGS+=(-DBUILD_TESTS=OFF)
fi

echo "CMake configuration:"
printf '%s\n' "\${CMAKE_ARGS[@]}"

cmake "\${CMAKE_ARGS[@]}" ..

# Build with appropriate parallelism
JOBS=\$(nproc)
if [ \$JOBS -gt 2 ]; then
    JOBS=2  # Limit to prevent OOM on GitHub runners
fi

echo "Building with \${JOBS} parallel jobs"
cmake --build . -j\${JOBS}

# Create output directory
mkdir -p /output

# Copy binaries
if [ -f bin/autoapp ]; then
    cp bin/autoapp /output/autoapp-\${TARGET_ARCH}
    echo "Copied autoapp binary"
fi

if [ -f bin/btservice ]; then
    cp bin/btservice /output/btservice-\${TARGET_ARCH}
    echo "Copied btservice binary"
fi

# Copy any other binaries
find bin -type f -executable 2>/dev/null | while read -r binary; do
    if [ "\$binary" != "bin/autoapp" ] && [ "\$binary" != "bin/btservice" ]; then
        basename_binary=\$(basename "\$binary")
        cp "\$binary" "/output/\${basename_binary}-\${TARGET_ARCH}"
        echo "Copied \$basename_binary binary"
    fi
done

echo "Build completed successfully for \${TARGET_ARCH}"
EOF

RUN chmod +x /build.sh

WORKDIR /src

CMD ["/build.sh"]